<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: http: https:;">
  <title>MessageIn显示端</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #121212;
      color: #ffffff;
      font-family: 'Microsoft YaHei', sans-serif;
    }
    
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    /* 弹幕轨道样式 */
    .danmaku-area {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 40px;
      overflow: hidden;
      z-index: 9999;
      pointer-events: none;
    }
    
    /* 弹幕样式 */
    .danmaku-item {
      position: absolute;
      white-space: nowrap;
      top: 4px;
      left: 100%;
      padding: 2px 8px;
      height: 32px;
      line-height: 32px;
      border-radius: 4px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      animation: danmaku-move 8s linear forwards;
      pointer-events: none;
    }
    
    /* 弹幕移动动画 */
    @keyframes danmaku-move {
      from {
        transform: translateX(0);
      }
      to {
        transform: translateX(-200%);
      }
    }
    
    /* 控制面板 */
    .control-panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1000;
      min-width: 320px;
    }
    
    .control-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .control-panel button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background-color: #1976d2;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    .control-panel button:hover {
      background-color: #1565c0;
    }
    
    .control-panel button.red {
      background-color: #f44336;
    }
    
    .control-panel button.red:hover {
      background-color: #d32f2f;
    }
    
    .control-panel button.green {
      background-color: #4caf50;
    }
    
    .control-panel button.green:hover {
      background-color: #388e3c;
    }
    
    .control-panel label {
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }
    
    .control-panel input[type="range"] {
      width: 120px;
    }
    
    .control-panel input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    
    .info-area {
      margin-top: auto;
      margin-bottom: 100px;
      text-align: center;
    }
    
    /* 背景样式 */
    .background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      background: linear-gradient(125deg, #1a237e, #0d47a1, #1565c0, #1976d2);
      background-size: 400% 400%;
      opacity: 0.5;
      animation: gradient-animation 15s ease infinite;
    }
    
    @keyframes gradient-animation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      margin-top: 10px;
    }
    
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background-color: #4caf50;
    }
    
    .status-dot.error {
      background-color: #f44336;
    }
    
    .external-window-mode {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: transparent !important;
      pointer-events: none;
    }
    
    .external-window-mode .danmaku-area {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 50px;
    }
    
    .external-window-mode .background,
    .external-window-mode .control-panel,
    .external-window-mode .info-area {
      display: none;
    }
    
    body.transparent-mode {
      background-color: transparent !important;
    }
    
    body.transparent-mode .background {
      display: none;
    }
    
    .electron-info {
      display: none; /* 默认隐藏 */
    }
    
    .electron-active .electron-info {
      display: block;
    }
    
    .logo {
      max-width: 200px;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div class="container" id="mainContainer">
    <!-- 弹幕区域 -->
    <div class="danmaku-area" id="danmakuArea"></div>
    
    <!-- 背景 -->
    <div class="background"></div>
    
    <!-- 信息区域 -->
    <div class="info-area">
      <h1>MessageIn显示端</h1>
      <p>正在从 <span id="apiUrlDisplay">http://www.cyupeng.com/message</span> 获取消息</p>
      <div class="status-indicator">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">正在连接...</span>
      </div>
      <div class="electron-info">
        <p>Electron模式已启用</p>
        <button id="createExternalBtn">创建外部窗口</button>
      </div>
    </div>
    
    <!-- 控制面板 -->
    <div class="control-panel">
      <div class="control-row">
        <button id="toggleBtn">暂停弹幕</button>
        <button id="testBtn">发送测试消息</button>
        <button id="clearBtn" class="red">清空弹幕</button>
      </div>
      
      <div class="control-row">
        <label>
          速度:
          <input type="range" id="speedRange" min="1" max="10" value="5">
        </label>
        
        <label>
          透明度:
          <input type="range" id="opacityRange" min="1" max="10" value="8">
        </label>
      </div>
      
      <div class="control-row">
        <label>
          <input type="checkbox" id="topMostCheck">
          始终置顶
        </label>
        
        <label>
          <input type="checkbox" id="transparentCheck">
          透明背景
        </label>
      </div>
    </div>
  </div>
  
  <script>
    // 检测是否在Electron环境中运行
    const isElectron = () => {
      return window.navigator.userAgent.toLowerCase().indexOf('electron') > -1 || 
             typeof window.electronAPI !== 'undefined';
    };
    
    // 弹幕系统
    class DanmakuSystem {
      constructor() {
        // 配置项
        this.apiUrl = 'http://www.cyupeng.com/message';
        this.pollingDelay = 1000;
        this.pollingInterval = null;
        this.lastContentHash = null;
        this.isRunning = true;
        this.danmakuArea = document.getElementById('danmakuArea');
        this.speed = 5; // 1-10，值越大弹幕速度越慢
        this.opacity = 0.8; // 0-1
        this.isElectronMode = isElectron();
        this.externalWindow = null;
        
        // 初始化DOM元素
        this.statusDot = document.getElementById('statusDot');
        this.statusText = document.getElementById('statusText');
        this.speedRange = document.getElementById('speedRange');
        this.opacityRange = document.getElementById('opacityRange');
        this.topMostCheck = document.getElementById('topMostCheck');
        this.transparentCheck = document.getElementById('transparentCheck');
        
        // 如果在Electron环境中，显示Electron特定功能
        if (this.isElectronMode) {
          document.body.classList.add('electron-active');
        }
        
        // 按钮事件
        document.getElementById('toggleBtn').addEventListener('click', () => this.toggleRunning());
        document.getElementById('testBtn').addEventListener('click', () => this.sendTestDanmaku());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearDanmaku());
        
        // 如果在Electron环境中，绑定创建外部窗口按钮
        if (this.isElectronMode && document.getElementById('createExternalBtn')) {
          document.getElementById('createExternalBtn').addEventListener('click', () => this.createExternalWindow());
        }
        
        // 其他控制选项
        this.speedRange.addEventListener('input', (e) => {
          this.speed = parseInt(e.target.value);
          this.updateDanmakuSpeed();
        });
        
        this.opacityRange.addEventListener('input', (e) => {
          this.opacity = parseFloat(e.target.value) / 10;
          this.updateDanmakuOpacity();
        });
        
        if (this.isElectronMode) {
          this.topMostCheck.addEventListener('change', (e) => {
            this.setAlwaysOnTop(e.target.checked);
          });
        }
        
        this.transparentCheck.addEventListener('change', (e) => {
          this.setTransparentBackground(e.target.checked);
        });
        
        // 初始化
        this.initCorsProxy();
        this.startPolling();
        
        // 显示状态
        this.updateStatus('连接中...', 'connecting');
      }
      
      // 更新状态显示
      updateStatus(text, status = 'success') {
        this.statusText.textContent = text;
        this.statusDot.className = 'status-dot' + (status === 'error' ? ' error' : '');
      }
      
      // 初始化CORS代理
      initCorsProxy() {
        this.corsProxies = [
          'https://api.codetabs.com/v1/proxy?quest=',
          'https://cors-proxy.fringe.zone/',
          'https://thingproxy.freeboard.io/fetch/'
        ];
      }
      
      // 开始轮询
      startPolling() {
        // 立即执行一次
        this.fetchMessages();
        
        // 设置定时器
        this.pollingInterval = setInterval(() => {
          this.fetchMessages();
        }, this.pollingDelay);
        
        console.log('已启动消息轮询，间隔:', this.pollingDelay, 'ms');
        this.updateStatus('已连接', 'success');
      }
      
      // 停止轮询
      stopPolling() {
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
          console.log('已停止消息轮询');
          this.updateStatus('已暂停', 'error');
        }
      }
      
      // 切换运行状态
      toggleRunning() {
        this.isRunning = !this.isRunning;
        const toggleBtn = document.getElementById('toggleBtn');
        
        if (this.isRunning) {
          toggleBtn.textContent = '暂停弹幕';
          this.startPolling();
        } else {
          toggleBtn.textContent = '恢复弹幕';
          this.stopPolling();
        }
      }
      
      // 更新弹幕速度
      updateDanmakuSpeed() {
        // 计算动画持续时间，值越大弹幕速度越慢
        const duration = 5 + (this.speed - 1) * (10 / 9); // 5-15秒
        
        // 创建或更新CSS样式
        let style = document.getElementById('danmakuSpeedStyle');
        if (!style) {
          style = document.createElement('style');
          style.id = 'danmakuSpeedStyle';
          document.head.appendChild(style);
        }
        
        style.textContent = `
          .danmaku-item {
            animation-duration: ${duration}s !important;
          }
        `;
      }
      
      // 更新弹幕透明度
      updateDanmakuOpacity() {
        // 创建或更新CSS样式
        let style = document.getElementById('danmakuOpacityStyle');
        if (!style) {
          style = document.createElement('style');
          style.id = 'danmakuOpacityStyle';
          document.head.appendChild(style);
        }
        
        style.textContent = `
          .danmaku-item {
            background-color: rgba(0, 0, 0, ${this.opacity}) !important;
          }
        `;
      }
      
      // 设置透明背景
      setTransparentBackground(isTransparent) {
        if (isTransparent) {
          document.body.classList.add('transparent-mode');
        } else {
          document.body.classList.remove('transparent-mode');
        }
        
        // 如果在Electron环境中，通知主进程
        if (this.isElectronMode && window.electronAPI) {
          window.electronAPI.updateDanmakuStyle({ transparent: isTransparent });
        }
      }
      
      // 设置始终置顶
      setAlwaysOnTop(isTopMost) {
        // 只在Electron环境中有效
        if (this.isElectronMode && window.electronAPI) {
          window.electronAPI.setAlwaysOnTop(isTopMost);
        }
      }
      
      // 创建外部窗口
      createExternalWindow() {
        // 只在Electron环境中有效
        if (this.isElectronMode && window.electronAPI) {
          window.electronAPI.createExternalWindow();
        }
      }
      
      // 清空弹幕
      clearDanmaku() {
        while (this.danmakuArea.firstChild) {
          this.danmakuArea.removeChild(this.danmakuArea.firstChild);
        }
      }
      
      // 获取消息
      async fetchMessages() {
        try {
          // 使用CORS代理获取消息
          const response = await this.fetchWithProxy(this.apiUrl);
          
          if (!response.ok) {
            throw new Error(`API请求失败: ${response.status}`);
          }
          
          // 获取原始文本
          const rawText = await response.text();
          console.log('API原始响应:', rawText);
          
          // 从原始文本中提取内容
          const content = this.extractContentFromText(rawText);
          console.log('提取的消息内容:', content);
          
          if (content) {
            // 计算内容哈希
            const contentHash = this.getContentHash(content);
            
            // 如果内容与上次不同，则处理新消息
            if (contentHash !== this.lastContentHash) {
              console.log('发现新消息:', content);
              this.lastContentHash = contentHash;
              this.addDanmaku(content);
              this.updateStatus('已收到新消息', 'success');
            }
          }
        } catch (error) {
          console.error('获取消息失败:', error);
          this.updateStatus('获取消息失败', 'error');
        }
      }
      
      // 使用代理获取URL内容
      async fetchWithProxy(url) {
        // 如果在Electron环境中，尝试直接请求
        if (this.isElectronMode) {
          try {
            console.log('Electron环境直接请求:', url);
            
            const directResponse = await fetch(url, {
              method: 'GET',
              headers: {
                'Accept': '*/*'
              }
            });
            
            if (directResponse.ok) {
              console.log('直接请求成功');
              return directResponse;
            }
          } catch (error) {
            console.warn('Electron直接请求失败，将尝试代理:', error);
          }
        }
        
        // 其他情况，先尝试直接请求
        try {
          console.log('尝试直接请求:', url);
          
          const directResponse = await fetch(url, {
            method: 'GET',
            mode: 'cors',
            headers: {
              'Accept': '*/*'
            }
          });
          
          if (directResponse.ok) {
            console.log('直接请求成功');
            return directResponse;
          }
        } catch (error) {
          console.warn('直接请求失败，将尝试代理:', error);
        }
        
        // 直接请求失败，尝试所有可用的代理
        let lastError;
        
        for (const proxy of this.corsProxies) {
          try {
            const proxyUrl = `${proxy}${encodeURIComponent(url)}`;
            console.log('尝试使用代理:', proxyUrl);
            
            const response = await fetch(proxyUrl, {
              method: 'GET',
              headers: {
                'Accept': '*/*'
              }
            });
            
            if (response.ok) {
              console.log('使用代理成功:', proxy);
              return response;
            } else {
              console.warn(`代理 ${proxy} 返回非200状态码:`, response.status);
            }
          } catch (error) {
            console.warn(`代理 ${proxy} 请求失败:`, error);
            lastError = error;
          }
        }
        
        console.error('所有尝试均失败');
        throw lastError || new Error('无法获取数据：所有请求方式均失败');
      }
      
      // 从文本中提取可能的消息内容
      extractContentFromText(text) {
        if (!text || typeof text !== 'string') {
          return null;
        }
        
        // 去除首尾空白
        const trimmed = text.trim();
        
        // 测试几种可能的格式
        
        // 1. 尝试作为JSON解析
        try {
          const json = JSON.parse(trimmed);
          if (json.content) {
            return json.content;
          }
          if (json.message) {
            return json.message;
          }
          return JSON.stringify(json);
        } catch (e) {
          // 不是有效的JSON，继续尝试
        }
        
        // 2. 尝试匹配类似 {'content':'大乐子'} 这样的格式
        const contentMatch = trimmed.match(/['"]content['"]:\s*['"](.+?)['"]/);
        if (contentMatch && contentMatch[1]) {
          return contentMatch[1];
        }
        
        // 3. 如果文本很短（小于100个字符），可能整个就是消息内容
        if (trimmed.length < 100) {
          return trimmed;
        }
        
        // 4. 否则尝试找到看起来像内容的部分
        const simpleContentMatch = trimmed.match(/{(.+?)}/);
        if (simpleContentMatch && simpleContentMatch[1]) {
          return simpleContentMatch[1];
        }
        
        // 5. 检查是否包含"大乐子"
        if (trimmed.includes('大乐子')) {
          return '大乐子';
        }
        
        // 如果以上都不匹配，返回原始文本
        return trimmed;
      }
      
      // 计算内容哈希，用于去重
      getContentHash(content) {
        let hash = 0;
        if (!content) return hash;
        for (let i = 0; i < content.length; i++) {
          const char = content.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash; // 转换为32位整数
        }
        return hash;
      }
      
      // 添加弹幕
      addDanmaku(content) {
        // 创建弹幕元素
        const danmaku = document.createElement('div');
        danmaku.className = 'danmaku-item';
        danmaku.textContent = content;
        
        // 设置随机颜色和字体大小
        danmaku.style.color = this.getRandomColor();
        danmaku.style.fontSize = `${18 + Math.floor(Math.random() * 4) * 2}px`;
        
        // 添加到DOM
        this.danmakuArea.appendChild(danmaku);
        
        // 弹幕动画结束后移除元素
        danmaku.addEventListener('animationend', () => {
          danmaku.remove();
        });
      }
      
      // 发送测试弹幕
      sendTestDanmaku() {
        const testMessages = [
          'MessageIn测试消息',
          '欢迎使用MessageIn显示端',
          '实时消息系统已启动',
          '这是一条测试消息',
          '这是一条长一点的MessageIn测试消息，用于测试显示效果'
        ];
        
        const randomIndex = Math.floor(Math.random() * testMessages.length);
        this.addDanmaku(testMessages[randomIndex]);
      }
      
      // 生成随机颜色
      getRandomColor() {
        const colors = [
          '#ffffff', // 白色
          '#ff4757', // 红色
          '#2ed573', // 绿色
          '#1e90ff', // 蓝色
          '#f1c40f', // 黄色
          '#e84393', // 粉色
          '#00cec9'  // 青色
        ];
        
        return colors[Math.floor(Math.random() * colors.length)];
      }
    }
    
    // Electron API模拟/包装
    class ElectronBridge {
      constructor() {
        this.isElectron = isElectron();
        
        if (this.isElectron && window.electronAPI) {
          console.log('Electron API 可用');
        } else {
          console.log('非Electron环境或API不可用');
        }
      }
      
      // 设置窗口始终置顶
      setAlwaysOnTop(value) {
        if (this.isElectron && window.electronAPI && window.electronAPI.setAlwaysOnTop) {
          window.electronAPI.setAlwaysOnTop(value);
        } else {
          console.log('模拟设置始终置顶:', value);
        }
      }
      
      // 创建外部窗口
      createExternalWindow() {
        if (this.isElectron && window.electronAPI && window.electronAPI.createExternalWindow) {
          window.electronAPI.createExternalWindow();
        } else {
          alert('此功能仅在Electron环境中可用');
        }
      }
      
      // 更新弹幕样式
      updateDanmakuStyle(style) {
        if (this.isElectron && window.electronAPI && window.electronAPI.updateDanmakuStyle) {
          window.electronAPI.updateDanmakuStyle(style);
        } else {
          console.log('模拟更新弹幕样式:', style);
        }
      }
    }
    
    // 初始化弹幕系统和Electron桥接
    document.addEventListener('DOMContentLoaded', () => {
      window.electronBridge = new ElectronBridge();
      window.danmakuSystem = new DanmakuSystem();
      
      // 检查URL参数
      const urlParams = new URLSearchParams(window.location.search);
      const mode = urlParams.get('mode');
      
      // 特殊模式处理
      if (mode === 'external' || mode === 'overlay') {
        document.getElementById('mainContainer').classList.add('external-window-mode');
        document.body.classList.add('transparent-mode');
      }
    });
    
    // 如果是Electron环境，设置预加载脚本中的API
    if (typeof window.electronAPI === 'undefined' && isElectron()) {
      window.electronAPI = {
        // 模拟API函数，实际在Electron中会被preload.js中的实际函数替换
        setAlwaysOnTop: (value) => console.log('需要实现 setAlwaysOnTop:', value),
        createExternalWindow: () => console.log('需要实现 createExternalWindow'),
        updateDanmakuStyle: (style) => console.log('需要实现 updateDanmakuStyle:', style)
      };
    }
  </script>
</body>
</html> 